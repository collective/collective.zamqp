================================
RabbitMQ:n käyttö ja integrointi
================================


RabbitMQ:n asennus
==================

RabbitMQ-palvelin on helppo asentaa kehitystä varten (jopa) samaan buildoutiin
Plonen kanssa. Buildout onnistuu reseptillä `rod.recipe.rabbitmq`_.

.. _rod.recipe.rabbitmq: http://pypi.python.org/pypi/rod.recipe.rabbitmq/2.0.0

Pelkästään RabbitMQ:n asentava ``buildout.cfg`` näyttää tältä::

    [buildout]
    parts = erlang rabbitmq

    [erlang]
    recipe = zc.recipe.cmmi
    url = http://www.erlang.org/download/otp_src_R13B02-1.tar.gz

    [rabbitmq]
    recipe = rod.recipe.rabbitmq
    erlang-path = ${erlang:location}/bin
    url = http://www.rabbitmq.com/releases/rabbitmq-server/v2.2.0/rabbitmq-server-2.2.0.tar.gz

Buildoutin jälkeen RabbitMQ:n käynnistetään komennoilla::

    source bin/rabbitmq-env  # korjaa RabbitMQ:n ympäristömuuttujat
    bin/rabbitmq-server


RabbitMQ:n käyttö
=================

Käynnistettyä RabbitMQ-palvelinta hyppyytetään `rabbitmqctl`_-komennolla.

.. _rabbitmqctl: http://www.rabbitmq.com/man/rabbitmqctl.1.man.html

Kehitystyön aluksi palvelimelle täytyy yleensä

1. luoda oma nimiavaruus (*virtual_host*)
2. luoda oma käyttäjä
3. myöntää omalle käyttäjälle riittävät oikeudet nimiavaruuteen


Plone-integraatio
=================

AMQP-viestijonojen käyttö Plonessa tapahtuu ``collective.zamqp``-lisäosalla
(lisäosa on yliopiston jatkokehittämä versio ``affinitic.zamqp``-lisäosasta).


Riippuvuudet
------------

Aloita kehitystyö määrittämällä oma viestijonoja tarvitseva lisäosasi
riippumaan ``collective.zamqp``-lisäosasta.

Lisäksi tarvitset riippuvuudeksi ``five.grok``:n, jotta määrittämäsi tuottajat
(*producers*) ja kuluttajat (*consumers*) rekisteröityisivät automaattisesti
Zopen ajonaikaiseen komponenttirekisteriin.

Jos haluat käyttää viestien sisällössä `msgpack`_-serialisointia, lisää
riippuvuuksien listaan myös ``msgpack-python`` (*msgpack*-serialisointia
tuetaan automaattisesti vain, jos se on itse määritetty riippuvuudeksi).

.. _msgpack: http://msgpack.org/


Lisäosasi ``setup.py``::

    install_requires=[
       # ...
       "five.grok",
       "collective.zamqp",
       "msgpack-python",
    ],

Lisäosasi ``configure.zcml``::

    <configure xmlns="http://namespaces.zope.org/zope"
               xmlns:grok="http://namespaces.zope.org/grok">

        <includeDependencies package="." />
        <grok:grok package="." />

    </configure>


Tuottaja (producer)
-------------------

Viestien tuottaja määritellään perimällä oma tuottaja ``collective.zamqp``:n
perusluokasta ja määrittämällä sille vähintään *nimi*, *viestien kohdevaihde*
ja käytettävän *yhteyden tunniste* (samanniminen yhteys määritetään
myöhemmin)::

    from five import grok
    from collective.zamqp.producer import Producer


    class MyProducer(Producer):
        grok.name("my_routing_key")

        connection_id = "my_amqp_connection"
        exchange = "my_exchange"

Oletuksena tuottaja lähettämiensä viestien reititysavaimena omaa nimeään, mutta
reititysavaimen voi määrittää myös itse::

    ... routing_key = "my_routing_key"

Oletuksena tuottajan lähettämät viestit määritellään säilymään palvelimella
uudelleenkäynnistyksen yli, mutta tämän voi estää määrittämällä itse::

    ... durable = False

Oletuksena tuottaja varmistaa, että välittäjäpalvelimella on tuottajan
tiedoissa määritetty vaihde, mutta myös tämän voi estää määrittämällä itse::

    ... auto_declare = False

Muita mielenkiintoisia ja tuottajan määrittelyssä muutettavia oletuksia ovat::

    ... exchange_type = 'direct'
    ... exchange_durable = None  # oletuksena sama kuin durable (ks. yllä)

    ... queue = None  # kun halutaan määrittää palvelimelle myös jono
    ... queue_durable = None
    ... queue_exclusive = False
    ... queue_arguments = {}

    ... reply_to = None
    ... serializer = 'text'  # esim. 'pickle' tai 'msgpack'

Viestin lähetys omasta lisäosasta tapahtuu pyytäällä komponenttirekisteristä
nimetty tuottaja, rekisteröimällä viesti(t) lähtemään vasta onnistuneen
transaktion päätteeksi (tai ilman rekisteröintiä välittömästi), ja lähettämällä
viesti tuottajan ``publish``-metodilla::

    producer = getUtility(IProducer, name="my_routing_key")
    producer._register()  # register for transaction
    producer.publish("Hello Consumer!")

Lähetyksessä voi antaa viestin lisäksi nimettyjä parametreja, joista
tärkeimmät ovat

routing_key
    Viestikohtainen reititysavain, jos ei haluta käyttää tuottajan
    määrittelyssä käytettyä reititysavainta.

correlation_id
    Viestikohtainen tunniste, jonka viestin vastaanottavan kuluttajan tulee
    liittää mukaan mahdolliseen vastausviestiin.

reply_to
    Viestikohtainen palautusavain, jonka mukaan viestin käsittelevän kuluttajan
    tulee reitittää mahdollinen vastausviesti.

serializer
    Viestin serialisointitapa, jos se eroaa tuottajan määrittelyssä käytetystä
    serialisoinnista. ``collective.zamqp`` tukee valmiiksi ainakin arvoja
    *text*, *pickle* ja *msgpack* (jos *msgpack-python* on käytettävissä).
    Tuettuja serialisointeja voi tarvittaessa myös määritellä lisää (ks.
    ``collective.zamqp.serializers``).

content_type
    Viestin muodon kertova otsikkotieto (esim. ``application/pdf``), jota
    käytetään silloin, kun serialisointia ei käytetä (``serialization=None``;
    esimerkiksi binaaritiedostoja lähetettäessä).

Jos tuottaja olisi määritetty käyttämään *msgpack*-serialisointia,
rakenteellisen (``<dict>``-muotoisen) viestin lähetys onnistuisi seuraavasti::

    producer.publish({"Subject": "Hello Consumer!"})


Kuluttaja (consumer)
--------------------

Viestien kuluttaja määritellään perimällä oma kuluttaja ``collective.zamqp``:n
perusluokasta ja määrittämällä sille vähintään *nimi*, käytettävän *yhteyden
tunniste* (yhteys määritetään myöhemmin) ja *leima* (*marker interface*), jonka
perusteella vastaanotetut viestit käsitellään::

    from five import grok

    from zope.interface import Interface
    from collective.zamqp.consumer import Consumer


    class IMyMessage(Interface):
        """Marker interface for messages received by MyConsumer"""


    class MyConsumer(Consumer):
        grok.name("my_queue")

        connection_id = "my_amqp_connection"
        marker = IMyMessage

Oletuksena kuluttaja olettaa kulutettavan jonon löytyvän välittäjäpalvelimelta,
mutta kuluttaja osaa myös määrittää jonon automaattisesti, kunhan sille
määritellään vähintään jonoon viestit reitittävän vaihteen nimi::

    ... exchange = "my_exchange"

Tällöin kuluttaja määrittää vaihteen, jonon (käyttäen jonon nimenä oletuksena
omaa nimeään) ja sitoo (*bind*) jonon nimellä reititettävät viestit
lähetettäväksi kuluttamaansa jonoon.

Kuluttajan oletuksia ja käyttäytymistä voi määrittää tarkemmin muokkaamalla
seuraavia oletuksia::

    ... routing_key = None
    ... durable = True

    ... exchange_type = 'direct'
    ... exchange_durable = None

    ... queue = None
    ... queue_durable = None
    ... queue_exclusive = False
    ... queue_arguments = {}

    ... auto_declare = True

    ... auto_ack = False


Tilaaja (subscriber)
--------------------

Kuluttaja ei itse käsittele viestejä, vaan ainoastaan vastaanottaa ne, leimaa
ne ja lähettää ne eteenpäin laukaisemalla Zopessa *IObjectEvent*-määrityksen
mukaisen *IMessageArrivedEvent*-tapahtuman.

Näin kuluttajan vastaanottamat ja tapahtumana edelleen jakamat viestit voi
tilata omassa lisäosassaan esimerkiksi seuraavasti::

    from collective.zamqp.interfaces import IMessageArrivedEvent


    @grok.subscribe(IMyMessage, IMessageArrivedEvent)
    def handleMessage(message, event):

        import logging
        logger = logging.getLogger()
        log.info("I got a new message", message)

        message.ack()

Huomaa, että viestinkäsittelyn aikana ympäristö vastaa täysin tavallisen
HTTP-pyynnön ympäristöä. Näin käsittely tapahtuu Zopen transaktion *sisällä*,
ja käsittelyn päätteeksi tapahtuu ``transaction.commit``.

Näin tilaaja voi esimerkiksi pyytää komponenttirekisteristä tuottajan ja
lähettää uusia viestejä.  Viestinkäsittely tapahtuu Zopen transaktiossa
tavallisen HTTP-pyynnön tapaan.

Oletuksena *aktiivisena käyttäjänä* viestinkäsittelyn aikana on tunnistamaton
*Anonymous User*-erikoiskäyttäjä (mutta käyttäjän voi määrittää tarkemmin
myöhemmin).

Ellei kuluttajalle ole määritetty ``auto_ack = True``, viesti täytyy erikseen
kuitata käsitellyksi ``message.ack()``-kutsulla. Muutoin välittäjä (*broker*)
toimittaa saman viestin myöhemmin uudelleen.

Viestiltä löytyvät ominaisuudet ovat

method_frame
    viestin välitystiedot

header_frame
    viestin otsikkotiedot

body
    viestin sisältö joko sellaisenaan tai purettuna, jos viesti tunnistetaan
    serialisoiduksi ja sen purkaminen on tuettu (viestin serialisointi
    päätellään ``content_type``-otsikkotiedosta).


Kulutus ilman tilaajaa
----------------------

Jos viestinkäsittely ei edellytä yhteyttä tietokantaan ja viestit voidaan
käsitellä poikkeuksetta hyvin lyhyessä ajassa, on viestit mahdollista käsitellä
suoraan kuluttajassa ylikirjoittamalla kuluttajan luokkamäärityksessä
viestinkäsittelymetodi esimerkiksi seuraavasti::

    class MyConsumer(Consumer):
        ...

        def on_message_received(self, channel, method_frame, header_frame, body):
            channel.basic_ack(delivery_tag=method_frame.delivery_tag)
            if self._tx_select:
                channel.tx_commit()  # min support for transactional channel
            logger.info("Acknowledged msg #'%s'." % method.frame.delivery_tag)

Kun viestit käsitellää edelläkuvatun esimerkin mukaisesti:

1. viestit täytyy kuitata Pikan APIn mukaisesti (ks. esimerkki), koska
   kutsu omalle käsittelymetodille tulee suoraan Pikalta
2. transaktionaalisen kanavan edellyttävä commit täytyy tarkistaa ja suorittaa
   itse (yhteyden transaktionaalisuus on tallennettu kuluttajaan totuusarvona
   nimellä ``_tx_select`` (ks. esimerkki)
3. kuluttajalle ei tarvitse määrittää ``marker``-tietoa.

Myöhemmin kuvattavien *ping*-viestien kulutus on toteutettu edellä esitetyn
esimerkin mukaisesti.


Yhteys
------

Tuottajat ja kuluttujat määritetään aina jollekin nimetylle AMQP-yhteydelle.
Nämä yhtedet voidaan määrittää joko lisäosan koodissa tai buildoutissa.

Yhteys määritetään buildoutissa laajentamalla Plonen-konfiguroinnissa käytetyn
reseptin tuottamaa ``zope.conf``-tiedostoa seuraavasti::

    [instance]
    recipe = plone.recipe.zope2instance
    ...
    zope-conf-additional +=
         %import collective.zamqp
         <amqp-broker-connection>
            connection_id my_amqp_connection
            hostname localhost
            port 5672
            virtual_host /my_virtualhost
            username my_username
            password my_password
            keepalive on
        </amqp-broker-connection>

Yhteyksiä voi määrittää tarvittavan määrän yksinkertaisesti toistamalla
``<amqp-broker-connection/>``-elementtiä tarvittava määrä. Huomaa, että
yhteydet täytyy nimetä (*connection_id*) ainutkertaisesti. Lisäksi yhteyden voi
määrittää transaktioita käyttäväksi asetusrivillä ``tx_select on``.


Kuluttajapalvelu
----------------

Viestien lähettämiseen riittää pelkkä tuottajien ja yhteyksien määrittäminen,
mutta viestien kuluttaminen edellyttää lisäksi yhteyskohtaisen
kuluttajapalvelun (*AMQP Consuming Server*) määrittämistä::

    ...  <amqp-consuming-server>
    ...     connection_id my_amqp_connection
    ...     site_id Plone
    ...  </amqp-consuming-server>

Kuluttajapalveluita voi määrittää tarvittavan määrän toistamalla
``<amqp-consumer-server/>``-elementtiä, mutta korkeintaan yksi per nimetty
yhteys. Esimerkissä näkyvien asetusten lisäksi kuluttajapalvelulle voi
määrittää käyttäjän (esim. *admin*), jonka nimissä viestit käsitellään::

    ...     user_id admin
    ...  </amqp-consuming-server>


Ping
----

.. note:: Versiosta ``collective.zamqp >= 0.7.2`` lähtien kaiken allaolevan on
   voinut määrittää automaattisesti lisäämällä ``<amqp-broker-connection/>``:n
   asetuksiin ``keepalive on``.

Jotta palomuuri ei katkaisisi hiljaista AMQP-yhteyttä, sitä täytyy pitää
hereillä joko AMQP:n heartbeat -palvelulla tai lähettämällä tasaisin väliajoin
yhteyttä auki pitäviä ping-viestejä (``collective.zamqp.keepalive`` sisältää
pohjaluokat ping-toiminnon määrittämisessä).

Koska AMQP:n heartbeat ei vielä toimi luotettavasti ``collective.zamqp``:n
kanssa (``pika == 0.9.5``), täytyy jokaista yhteyttä kohden määrittää

1. yksi ping-tuottaja::

    from zope.interface import Interface
    from collective.zamqp import keepalive


    class PingProducer(keepalive.PingProducer):
        grok.name("my_amqp_ping")
        connection_id = "my_amqp_connection"

2. yksi ping-kuluttaja::

    class PingConsumer(keepalive.PingConsumer):
        grok.name("my_amqp_ping")
        connection_id = "my_amqp_connection"

3. näkymä, joka lähettää ping-viestin::

    class PingView(grok.View):
        grok.name("my-amqp-ping")
        grok.context(OFS.IApplication)
        grok.require("zope.Public")

        render = lambda self: keepalive.ping("my_amqp_ping")

4. ajastus buildoutin ``zope-conf-additional =+``-asetuksessa::

    ... <clock-server>
    ...     method /@@my-amqp-ping
    ...     period 60
    ...     host localhost
    ... </clock-server>


Brokerin debuggaus
==================

Brokeria on mahdollista hallita rajallisesti etäyhteydellä käyttäen Celeryn
mukana tulevaa camqadm_-työkalua.

.. _camqadm: http://docs.celeryproject.org/en/latest/userguide/routing.html#hands-on-with-the-api

1. Tee uusi virtualenv::

    virtualenv amqpcli

2. Aktivoi::

    source amqpcli/activate

3. Asenna Celery::

    pip install celery

4. Käynnistä AMQP-konsoli::

    camqadm --broker=amqp://username:password@hostname:5672//virtualhost

